import React, { ReactElement } from 'react';

interface IAtomValueBase {
    initVer: number;
    touched?: boolean;
    validate?: (data: any, otherParams?: any) => string | undefined | null;
    error?: string | null;
    type: IFieldType;
}
interface IFieldAtomValue<D = any, E = any> extends IAtomValueBase {
    data?: D;
    extraInfo?: E;
}
interface IFieldArrayAtomValue extends IAtomValueBase {
    rowIds: number[];
    fieldNames: IChildFieldInfo[];
    skipUnregister?: boolean;
}
interface InitialValues {
    values: any;
    extraInfos: any;
    version: number;
    settings?: {
        skipUnregister?: boolean;
        skipUnusedInitialValues?: boolean;
    };
}
interface FinalValues {
    values: any;
    extraInfos: any;
}
interface IRemoveFieldParams {
    fieldNames: (string | {
        ancestors?: {
            name: string;
            rowId: number;
        }[];
        name: string;
    })[];
}
interface IFieldWatchParams {
    fieldNames: (string | {
        ancestors?: {
            name: string;
            rowId: number;
        }[];
        name: string;
    })[];
    /**
     * This is needed only for the advanced case of watching field outside the FormProvider hierarchy (assuming a formId was specified).
     * Ideally this should never be defined.
     */
    formId?: string;
}
interface IFieldArrayColWatchParams {
    ancestors?: {
        name: string;
        rowId: number;
    }[];
    fieldArrayName: string;
    fieldNames?: string[];
    /**
     * This is optional and needed only for watching field outside the FormProvider hierarchy (assuming a formId was specified).
     * Ideally this should never be defined.
     */
    formId?: string;
}
declare type IFieldType = 'field' | 'field-array';
interface IAncestorInput {
    name: string;
    rowId: number;
}
interface IFieldProps<D> {
    /**
     * Only required if the field is part of field array
     */
    ancestors?: {
        name: string;
        rowId: number;
    }[];
    name: string;
    defaultValue?: D;
    /**
     * validate is only allowed to be set once when useField() is invoked.
     * If you need to use some external state for validation, please use validateCallback instead
     */
    validate?: (value?: D, otherParams?: any) => string | undefined | null;
    /**
     * validateCallback will be a function wrapped in useCallback() and this will be updated
     * for internal state changes. Please be careful to make sure it has a fixed list of dependencies
     * and doesn't change all the time since that can cause an infinite loop.
     */
    validateCallback?: (value?: D, otherParams?: any) => string | undefined | null;
    /**
     * Useful for referencing other fields in validation
     * */
    depFields?: (string | {
        name: string;
        ancestors?: {
            name: string;
            rowId: number;
        }[];
    })[];
    skipUnregister?: boolean;
}
declare type IChildFieldInfo = string | {
    name: string;
    type: 'field';
} | {
    name: string;
    type: 'field-array';
    fieldNames: IChildFieldInfo[];
};
interface IFieldArrayProps {
    name: string;
    /**
     * Name of the fields for this field array.
     * Note that by default it's assumed to be of type 'field'
     */
    fieldNames: IChildFieldInfo[];
    validate?: (values: any[], otherParams?: any) => string | undefined | null;
    depFields?: string[];
    skipUnregister?: boolean;
    ancestors?: IAncestorInput[];
    defaultValue?: any[];
}
interface IFieldAtomInput {
    ancestors: IAncestorInput[];
    name: string;
}
interface IGetFieldArrayInput extends IFieldAtomInput {
    fieldNames?: string[];
}
interface IFieldArrayRowInput extends IFieldAtomInput {
    rowId: number;
}
interface IFormContextFieldInput {
    type: IFieldType;
    ancestors?: IAncestorInput[];
    name: string;
}
declare type IFieldAtomSelectorInput = {
    ancestors: {
        name: string;
        rowId: number;
    }[];
    name: string;
    type: IFieldType;
    formId: string;
};
interface IFieldError {
    ancestors: {
        name: string;
        rowId: number;
    }[];
    name: string;
    type: IFieldType;
    error: string;
}
interface IIsDirtyProps {
    preCompareUpdateFormValues?: (formValues: any) => any;
}

declare function useField<D = any, E = any>(props: IFieldProps<D>): {
    fieldValue: D | undefined;
    initValueVer: number;
    extraInfo: E | undefined;
    setFieldValue: (data: D, extraInfo?: E) => void;
    error: string | null | undefined;
    onBlur: () => void;
    touched: boolean | undefined;
};
declare function useFieldWatch(props: IFieldWatchParams): {
    values: {
        [key: string]: any;
    };
    extraInfos: {
        [key: string]: any;
    };
};
declare function useFieldArrayColumnWatch(props: IFieldArrayColWatchParams): {
    values: any[];
    extraInfos: any[];
};
declare function useIsDirty(options?: IIsDirtyProps): boolean;
declare function useFormValues(): any;
declare function useFormContext(): {
    getValue: (key: IFormContextFieldInput) => {
        value: any;
        extraInfo: any;
    } | null;
    setValue: (key: string | IFormContextFieldInput, newValue: {
        value?: any;
        extraInfo?: any;
    }) => void;
    getValues: (...args: any) => any;
    checkIsDirty: (...args: any) => any;
    removeFields: (...args: any) => any;
    resetInitialValues: (values?: any, extraInfos?: any) => void;
};
declare function useFieldArray(props: IFieldArrayProps): {
    append: (...args: any[]) => void;
    remove: (index: number) => void;
    fieldArrayProps: IFieldArrayAtomValue;
    insert: (index: number, ...rows: any[]) => void;
    validateData: () => {
        errors: IFieldError[] | undefined;
        isValid: boolean;
    };
    removeAll: () => void;
    getFieldArrayValue: () => any[];
    setFieldArrayValue: (fieldValues: any[]) => void;
    error: string | null | undefined;
};
interface IFormProps {
    onSubmit: (values: any, extraInfos?: any) => any;
    onError?: (errors?: IFieldError[] | null, formErrors?: any[] | null, values?: any) => any;
    initialValues?: any;
    /**
     * Useful in cases where you want to show the errors at the form level rather than field level
     * To show field level errors, please use validate() function in useField instead
     */
    validate?: (data: any) => string[] | null | undefined;
    /**
     * Should data be preserved if a field unmounts?
     * By default, this is false
     */
    skipUnregister?: boolean;
    /**
     * Reinitialize the form after submit back to the specified initial or empty values.
     * E.g. After changing password, you want to clear all the input fields
     */
    reinitializeOnSubmit?: boolean;
    /**
     * If true, initial values not mapped to  form fields, will not come in the output
     */
    skipUnusedInitialValues?: boolean;
}
declare function useForm(props: IFormProps): {
    handleSubmit: (e?: React.FormEvent<HTMLFormElement>) => any;
    formState: {
        isSubmitting: boolean;
    };
    handleReset: () => void;
    resetInitialValues: (values?: any, extraInfos?: any) => void;
    validateFields: (fieldNames?: (string | IFormContextFieldInput)[] | undefined) => IFieldError[];
    validateAllFields: () => IFieldError[];
    getValues: () => {
        values: any;
        extraInfos: any;
    };
};
interface FormProviderOptions {
    /**
     * Use this option only if you already have another <RecoilRoot> in your application
     */
    skipRecoilRoot?: boolean;
    /**
     * Skip dirty check and real-time observer for form values. This can result in better performance in some cases.
     */
    skipValuesObserver?: boolean;
    /**
     * This only needs to be specified for advanced cases where you want to watch fields outside the current hierarchy.
     * Note that skipRecoilRoot should also be set to true for this use case.
     */
    formId?: string;
}
declare function FormProvider(props: {
    children: any;
    options?: FormProviderOptions;
}): JSX.Element;
declare const withFormProvider: (Component: any, options?: FormProviderOptions) => ({ ...props }: {
    [x: string]: any;
}) => JSX.Element;

interface IRenderProps {
    value: any;
    onChange: (data: any, extraInfo?: any) => void;
    error: string | null | undefined;
}
declare type RenderProps = (props: IRenderProps) => void;
interface IField {
    children?: RenderProps | ReactElement;
    name: string;
    required?: boolean;
    defaultValue?: any;
    handleChange?: (value?: any) => void;
    ancestors?: IAncestorInput[];
    validate?: (value?: any, otherParams?: any) => string | null | undefined;
}
declare const Field: (props: IField) => JSX.Element;

export { Field, FinalValues, FormProvider, IAncestorInput, IAtomValueBase, IChildFieldInfo, IFieldArrayAtomValue, IFieldArrayColWatchParams, IFieldArrayProps, IFieldArrayRowInput, IFieldAtomInput, IFieldAtomSelectorInput, IFieldAtomValue, IFieldError, IFieldProps, IFieldType, IFieldWatchParams, IFormContextFieldInput, IGetFieldArrayInput, IIsDirtyProps, IRemoveFieldParams, InitialValues, useField, useFieldArray, useFieldArrayColumnWatch, useFieldWatch, useForm, useFormContext, useFormValues, useIsDirty, withFormProvider };
